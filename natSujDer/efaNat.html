<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Oscar Sedano Vargas">

<title>Análisis Factorial Exploratorio: Escalas de Perspectiva Ambiental</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="efaNat_files/libs/clipboard/clipboard.min.js"></script>
<script src="efaNat_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="efaNat_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="efaNat_files/libs/quarto-html/popper.min.js"></script>
<script src="efaNat_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="efaNat_files/libs/quarto-html/anchor.min.js"></script>
<link href="efaNat_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="efaNat_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="efaNat_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="efaNat_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="efaNat_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


<link rel="stylesheet" href="styles.css">
</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#introducción" id="toc-introducción" class="nav-link active" data-scroll-target="#introducción">Introducción</a></li>
  <li><a href="#parte-1-análisis-del-instrumento-global" id="toc-parte-1-análisis-del-instrumento-global" class="nav-link" data-scroll-target="#parte-1-análisis-del-instrumento-global"><strong>Parte 1: Análisis del Instrumento Global</strong></a></li>
  <li><a href="#parte-2-análisis-jerárquico-de-las-subescalas" id="toc-parte-2-análisis-jerárquico-de-las-subescalas" class="nav-link" data-scroll-target="#parte-2-análisis-jerárquico-de-las-subescalas"><strong>Parte 2: Análisis Jerárquico de las Subescalas</strong></a></li>
  <li><a href="#afe-para-la-subescala-biocéntrica-confirmando-1-factor" id="toc-afe-para-la-subescala-biocéntrica-confirmando-1-factor" class="nav-link" data-scroll-target="#afe-para-la-subescala-biocéntrica-confirmando-1-factor">AFE para la subescala Biocéntrica (confirmando 1 factor)</a></li>
  <li><a href="#afe-para-la-subescala-antropocéntrica-confirmando-1-factor" id="toc-afe-para-la-subescala-antropocéntrica-confirmando-1-factor" class="nav-link" data-scroll-target="#afe-para-la-subescala-antropocéntrica-confirmando-1-factor">AFE para la subescala Antropocéntrica (confirmando 1 factor)</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Análisis Factorial Exploratorio: Escalas de Perspectiva Ambiental</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Oscar Sedano Vargas </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introducción" class="level2">
<h2 class="anchored" data-anchor-id="introducción">Introducción</h2>
<p>Este documento detalla el proceso de Análisis Factorial Exploratorio (AFE) para validar un instrumento diseñado para medir las perspectivas <strong>biocéntrica</strong> y <strong>antropocéntrica</strong>. El objetivo es explorar la estructura subyacente del instrumento, depurar las escalas y confirmar su unidimensionalidad.</p>
<hr>
<section id="paso-0-cargar-librerías" class="level3">
<h3 class="anchored" data-anchor-id="paso-0-cargar-librerías"><strong>Paso 0: Cargar Librerías</strong></h3>
<p>Primero, cargamos todos los paquetes de R que necesitaremos para el análisis. <code>psych</code> es para el análisis factorial, <code>EFAtools</code> para el análisis paralelo, y <code>dplyr</code> para la manipulación de datos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(psych)      <span class="co"># Para EFA con fa()</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(EFAtools)   <span class="co"># Para Análisis Paralelo</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)      <span class="co"># Para manipulación de datos con %&gt;%</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
</section>
</section>
<section id="parte-1-análisis-del-instrumento-global" class="level2">
<h2 class="anchored" data-anchor-id="parte-1-análisis-del-instrumento-global"><strong>Parte 1: Análisis del Instrumento Global</strong></h2>
<p>El primer gran paso es analizar todos los ítems juntos para probar la hipótesis principal: que el instrumento mide dos grandes factores (Biocentrismo y Antropocentrismo).</p>
<section id="paso-1.1-preparación-de-datos" class="level3">
<h3 class="anchored" data-anchor-id="paso-1.1-preparación-de-datos"><strong>Paso 1.1: Preparación de Datos</strong></h3>
<p>Cargamos la base de datos final desde el archivo <code>bdNat.Rdata</code>. Luego, la depuramos, eliminando los ítems que en análisis preliminares demostraron ser problemáticos y las columnas que no son ítems de la escala Likert.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Cargamos el objeto 'bd' directamente desde el archivo .Rdata</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Asegúrate de que el archivo "bdNat.Rdata" esté en el mismo directorio de trabajo.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">setwd</span>(<span class="st">"D:/IntellijIDEA_Projects/artcls2025/natSujDer"</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">load</span>(<span class="st">"bdNat.Rdata"</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Creamos el dataframe para el análisis (dbEfa)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Tomamos la base original (`bd`)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Eliminamos los ítems problemáticos identificados previamente.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. Eliminamos columnas de identificación o demográficas.</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>dbEfa <span class="ot">&lt;-</span> bd <span class="sc">%&gt;%</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span><span class="fu">c</span>(q1_bf_ant, q3_al_ant, q15_al_ant, q17_td_ant, q25_al_bio, q28_rep_bio, q16_bf_bio)) <span class="sc">%&gt;%</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span>(id<span class="sc">:</span>Condition))</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Vemos las dimensiones del dataframe limpio</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co"># dim(dbEfa)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="paso-1.2-decidir-el-número-de-factores" class="level3">
<h3 class="anchored" data-anchor-id="paso-1.2-decidir-el-número-de-factores"><strong>Paso 1.2: Decidir el Número de Factores</strong></h3>
<p>Antes de correr el AFE, usamos un método empírico para determinar el número óptimo de factores a extraer. El <strong>Análisis Paralelo</strong> es el método más recomendado. Compara los autovalores de nuestros datos con los de datos aleatorios para sugerir cuántos factores son estadísticamente significativos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ejecutamos el Análisis Paralelo sobre el conjunto completo de ítems.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Esto nos ayuda a justificar nuestra decisión teórica de 2 factores.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Damos prioridad al resultado de "PCA-determined eigenvalues".</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>EFAtools<span class="sc">::</span><span class="fu">PARALLEL</span>(dbEfa)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>ℹ 'x' was not a correlation matrix. Correlations are found from entered raw data.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Parallel Analysis performed using 1000 simulated random data sets
Eigenvalues were found using PCA, SMC, and EFA

Decision rule used: means

── Number of factors to retain according to ────────────────────────────────────

◌ PCA-determined eigenvalues:  2
◌ SMC-determined eigenvalues:  NA
◌ EFA-determined eigenvalues:  3</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="efaNat_files/figure-html/parallel-main-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="efaNat_files/figure-html/parallel-main-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="efaNat_files/figure-html/parallel-main-3.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="paso-1.3-ejecutar-el-afe-principal-2-factores" class="level3">
<h3 class="anchored" data-anchor-id="paso-1.3-ejecutar-el-afe-principal-2-factores"><strong>Paso 1.3: Ejecutar el AFE Principal (2 Factores)</strong></h3>
<p>Con la justificación teórica y empírica, procedemos a ejecutar el AFE principal forzando una solución de 2 factores.</p>
<ul>
<li><code>nfactors = 2</code>: Le ordenamos al modelo que busque dos factores.</li>
<li><code>cor = "poly"</code>: Usamos correlaciones policóricas, el método correcto para escalas tipo Likert (ordinales).</li>
<li><code>fm = "pa"</code>: Usamos “Principal Axis Factoring”, un método de extracción robusto que no asume normalidad.</li>
<li><code>rotate = "oblimin"</code>: Usamos una rotación oblicua, que permite que los dos factores estén correlacionados.</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ejecutamos el modelo.</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Es importante mostrar las advertencias (warnings) aquí,</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ya que nos recuerdan la inestabilidad de la matriz al analizar todos los ítems juntos.</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>modEfa <span class="ot">&lt;-</span> psych<span class="sc">::</span><span class="fu">fa</span>(</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">r =</span> dbEfa,</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">nfactors =</span> <span class="dv">2</span>,</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">cor =</span> <span class="st">"poly"</span>,</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">fm =</span> <span class="st">"pa"</span>,</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">rotate =</span> <span class="st">"oblimin"</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in cor.smooth(mat): Matrix was not positive definite, smoothing was
done</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required namespace: GPArotation</code></pre>
</div>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Imprimimos los resultados.</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co"># cut = 0.4 -&gt; Oculta cargas factoriales bajas para una mejor lectura.</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co"># sort = TRUE -&gt; Ordena los ítems por su carga factorial.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(modEfa, <span class="at">cut =</span> <span class="fl">0.4</span>, <span class="at">sort =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Factor Analysis using method =  pa
Call: psych::fa(r = dbEfa, nfactors = 2, rotate = "oblimin", fm = "pa", 
    cor = "poly")
Standardized loadings (pattern matrix) based upon correlation matrix
            item   PA1   PA2   h2   u2 com
q11_td_bio     9  0.86       0.79 0.21 1.1
q14_rep_bio   12  0.82       0.75 0.25 1.1
q21_bf_bio    16  0.77       0.62 0.38 1.2
q6_bf_bio      4  0.74       0.54 0.46 1.0
q13_al_bio    11  0.74       0.55 0.45 1.0
q12_bf_bio    10  0.73       0.59 0.41 1.1
q4_td_bio      2  0.72       0.61 0.39 1.5
q19_td_bio    14  0.71       0.51 0.49 1.0
q10_bf_bio     8  0.66       0.45 0.55 1.1
q9_td_bio      7  0.66       0.45 0.55 1.1
q5_al_bio      3  0.60       0.41 0.59 1.3
q18_rep_ant   13        0.80 0.64 0.36 1.0
q22_bf_ant    17        0.78 0.63 0.37 1.0
q20_bf_ant    15        0.73 0.54 0.46 1.1
q26_td_ant    20        0.67 0.45 0.55 1.0
q7_al_ant      5        0.66 0.45 0.55 1.1
q27_bf_ant    21        0.64 0.40 0.60 1.0
q8_rep_ant     6        0.63 0.44 0.56 1.1
q23_td_ant    18        0.63 0.47 0.53 1.3
q24_td_ant    19        0.62 0.40 0.60 1.0
q2_bf_ant      1        0.55 0.32 0.68 1.1

                       PA1  PA2
SS loadings           6.05 4.96
Proportion Var        0.29 0.24
Cumulative Var        0.29 0.52
Proportion Explained  0.55 0.45
Cumulative Proportion 0.55 1.00

 With factor correlations of 
      PA1   PA2
PA1  1.00 -0.07
PA2 -0.07  1.00

Mean item complexity =  1.1
Test of the hypothesis that 2 factors are sufficient.

df null model =  210  with the objective function =  41.77 with Chi Square =  5604.06
df of  the model are 169  and the objective function was  30.72 

The root mean square of the residuals (RMSR) is  0.09 
The df corrected root mean square of the residuals is  0.1 

The harmonic n.obs is  143 with the empirical chi square  441.51  with prob &lt;  3.1e-26 
The total n.obs was  143  with Likelihood Chi Square =  4080.01  with prob &lt;  0 

Tucker Lewis Index of factoring reliability =  0.09
RMSEA index =  0.402  and the 90 % confidence intervals are  0.393 0.414
BIC =  3241.29
Fit based upon off diagonal values = 0.95
Measures of factor score adequacy             
                                                   PA1  PA2
Correlation of (regression) scores with factors   0.99 0.96
Multiple R square of scores with factors          0.98 0.92
Minimum correlation of possible factor scores     0.96 0.84</code></pre>
</div>
</div>
<hr>
</section>
</section>
<section id="parte-2-análisis-jerárquico-de-las-subescalas" class="level2">
<h2 class="anchored" data-anchor-id="parte-2-análisis-jerárquico-de-las-subescalas"><strong>Parte 2: Análisis Jerárquico de las Subescalas</strong></h2>
<p>Una vez validada la estructura de dos grandes factores, “hacemos zoom” en cada uno para confirmar su unidimensionalidad.</p>
<section id="paso-2.1-separar-las-subescalas" class="level3">
<h3 class="anchored" data-anchor-id="paso-2.1-separar-las-subescalas"><strong>Paso 2.1: Separar las Subescalas</strong></h3>
<p>Creamos dos nuevos dataframes, uno para cada constructo, usando los ítems finales depurados.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Seleccionamos las columnas que contienen "bio" para la escala Biocéntrica</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>bio <span class="ot">&lt;-</span> dbEfa <span class="sc">%&gt;%</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="fu">contains</span>(<span class="st">"bio"</span>))</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Seleccionamos las columnas que contienen "ant" para la escala Antropocéntrica</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>ant <span class="ot">&lt;-</span> dbEfa <span class="sc">%&gt;%</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">select</span>(<span class="fu">contains</span>(<span class="st">"ant"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="paso-2.2-decidir-factores-para-cada-subescala" class="level3">
<h3 class="anchored" data-anchor-id="paso-2.2-decidir-factores-para-cada-subescala"><strong>Paso 2.2: Decidir Factores para Cada Subescala</strong></h3>
<p>Repetimos el Análisis Paralelo, esta vez por separado para cada subescala. Esto nos dirá si cada una de ellas es, en efecto, unidimensional.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Análisis Paralelo para la subescala Biocéntrica</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>EFAtools<span class="sc">::</span><span class="fu">PARALLEL</span>(bio)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>ℹ 'x' was not a correlation matrix. Correlations are found from entered raw data.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Parallel Analysis performed using 1000 simulated random data sets
Eigenvalues were found using PCA, SMC, and EFA

Decision rule used: means

── Number of factors to retain according to ────────────────────────────────────

◌ PCA-determined eigenvalues:  1
◌ SMC-determined eigenvalues:  5
◌ EFA-determined eigenvalues:  4</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="efaNat_files/figure-html/parallel-subscales-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="efaNat_files/figure-html/parallel-subscales-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="efaNat_files/figure-html/parallel-subscales-3.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Análisis Paralelo para la subescala Antropocéntrica</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>EFAtools<span class="sc">::</span><span class="fu">PARALLEL</span>(ant)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>ℹ 'x' was not a correlation matrix. Correlations are found from entered raw data.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Parallel Analysis performed using 1000 simulated random data sets
Eigenvalues were found using PCA, SMC, and EFA

Decision rule used: means

── Number of factors to retain according to ────────────────────────────────────

◌ PCA-determined eigenvalues:  1
◌ SMC-determined eigenvalues:  5
◌ EFA-determined eigenvalues:  2</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="efaNat_files/figure-html/parallel-subscales-4.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="efaNat_files/figure-html/parallel-subscales-5.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="efaNat_files/figure-html/parallel-subscales-6.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><em>Nota: En ambos casos, el método más fiable (PCA-determined) sugiere <strong>1 solo factor</strong>, lo que nos da luz verde para probar la unidimensionalidad.</em></p>
</section>
<section id="paso-2.3-ejecutar-los-afe-finales-1-factor" class="level3">
<h3 class="anchored" data-anchor-id="paso-2.3-ejecutar-los-afe-finales-1-factor"><strong>Paso 2.3: Ejecutar los AFE Finales (1 Factor)</strong></h3>
<p>Finalmente, corremos un AFE para cada subescala forzando una solución de 1 factor. Esto nos permite ver las cargas factoriales de cada ítem en su constructo y evaluar la coherencia interna de cada escala final.</p>
<p>#| label: efa-final</p>
</section>
</section>
<section id="afe-para-la-subescala-biocéntrica-confirmando-1-factor" class="level1">
<h1>AFE para la subescala Biocéntrica (confirmando 1 factor)</h1>
<p>modelo_bio_final &lt;- fa( r = bio, nfactors = 1, cor = “poly”, fm = “pa” ) print(modelo_bio_final)</p>
</section>
<section id="afe-para-la-subescala-antropocéntrica-confirmando-1-factor" class="level1">
<h1>AFE para la subescala Antropocéntrica (confirmando 1 factor)</h1>
<p>modelo_ant_final &lt;- fa( r = ant, nfactors = 1, cor = “poly”, fm = “pa” ) print(modelo_ant_final)</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>